// Generated by simple:form

import success from "../assets/success.png";
import { type ComponentProps, createContext } from "react";
import { useContext, useState } from "react";
import {
	type FieldErrors,
	type FormState,
	type FormValidator,
	formNameInputProps,
	getInitialFormState,
	toSetValidationErrors,
	toTrackAstroSubmitStatus,
	toValidateField,
	validateForm,
} from "simple:form";

export function useCreateFormContext(
	validator: FormValidator,
	fieldErrors?: FieldErrors
) {
	const initial = getInitialFormState({ validator, fieldErrors });
	const [formState, setFormState] = useState<FormState>(initial);
	return {
		value: formState,
		set: setFormState,
		setValidationErrors: toSetValidationErrors(setFormState),
		validateField: toValidateField(setFormState),
		trackAstroSubmitStatus: toTrackAstroSubmitStatus(setFormState),
	};
}

export function useFormContext() {
	const formContext = useContext(FormContext);
	if (!formContext) {
		throw new Error(
			"Form context not found. `useFormContext()` should only be called from children of a <Form> component."
		);
	}
	return formContext;
}

type FormContextType = ReturnType<typeof useCreateFormContext>;

const FormContext = createContext<FormContextType | undefined>(undefined);

export function Form({
	children,
	validator,
	context,
	fieldErrors,
	name,
	...formProps
}: {
	validator: FormValidator;
	context?: FormContextType;
	fieldErrors?: FieldErrors;
} & Omit<ComponentProps<"form">, "method" | "onSubmit">) {
	const internalContext = useCreateFormContext(validator, fieldErrors);
	const formContext = context ?? internalContext;
	const [sentSuccessfully, setSentSuccessfully] = useState(false);

	return (
		<>
			{sentSuccessfully ? (
				<MessageSucceeded />
			) : (
				<FormContext.Provider value={formContext}>
					<form
						{...formProps}
						method="POST"
						action="/"
						id="contact-form"
						onSubmit={async (e) => {
							e.preventDefault();
							e.stopPropagation();

							const formData = new FormData(e.currentTarget);
							formContext.set((formState) => ({
								...formState,
								isSubmitPending: true,
								submitStatus: "validating",
							}));

							const parsed = await validateForm({
								formData,
								validator,
							});

							if (parsed.data) {
								const response = await fetch("/api/contact", {
									method: "POST",
									body: formData,
								});

								if (response.ok) {
									const json = await response.json();
									if (json.success) {
										setSentSuccessfully(json.success);
										e.currentTarget.reset();
									}
								} else {
									console.error("Form submission failed:", response.status);
								}

								return;
							}

							formContext.set((formState) => ({
								...formState,
								isSubmitPending: false,
								submitStatus: "idle",
							}));
							formContext.setValidationErrors(parsed.fieldErrors);
						}}
					>
						{name ? (
							<input {...formNameInputProps} value={name} />
						) : null}
						{children}
					</form>
				</FormContext.Provider>
			)}
		</>
	);
}

export function Input(inputProps: ComponentProps<"input"> & { name: string }) {
	const formContext = useFormContext();
	const fieldState = formContext.value.fields[inputProps.name];

	// Defensive check - render basic input during hydration
	if (!fieldState) {
		return <input {...inputProps} />;
	}

	const { hasErroredOnce, validationErrors, validator } = fieldState;
	return (
		<>
			<input
				onBlur={async (e) => {
					const value = e.currentTarget.value;
					if (value === "") return;
					formContext.validateField(inputProps.name, value, validator);
				}}
				onInput={async (e) => {
					if (!hasErroredOnce) return;
					const value = e.currentTarget.value;
					formContext.validateField(inputProps.name, value, validator);
				}}
				{...inputProps}
			/>
			{validationErrors && validationErrors.length > 0 && (
				<p className="text-red-500 text-xs mt-1">
					{validationErrors.at(0) === "Required"
						? "Requerido"
						: validationErrors.at(0)}
				</p>
			)}
		</>
	);
}

export function Select({
	name,
	options = [],
	...inputProps
}: ComponentProps<"select"> & {
	name: string;
	options?: { value: string; label: string }[];
}) {
	const formContext = useFormContext();
	const fieldState = formContext.value.fields[name];

	// Defensive check - render basic select during hydration
	if (!fieldState) {
		return (
			<select {...inputProps} name={name} defaultValue={"seleccione"}>
				<option value="seleccione" disabled>
					Seleccione
				</option>
				{options?.map((option) => (
					<option key={option.value} value={option.value}>
						{option.label}
					</option>
				))}
			</select>
		);
	}

	const { hasErroredOnce, validationErrors, validator } = fieldState;

	return (
		<>
			<select
				{...inputProps}
				name={name}
				defaultValue={"seleccione"}
				onBlur={async (e) => {
					const value = e.currentTarget.value;
					if (value === "") return;
					formContext.validateField(name, value, validator);
				}}
				onInput={async (e) => {
					if (!hasErroredOnce) return;
					const value = e.currentTarget.value;
					formContext.validateField(name, value, validator);
				}}
			>
				<option value="seleccione" disabled>
					Seleccione
				</option>
				{options?.map((option) => (
					<option key={option.value} value={option.value}>
						{option.label}
					</option>
				))}
			</select>
			{validationErrors && validationErrors.length > 0 && (
				<p className="text-red-500 text-xs mt-1">
					{validationErrors.at(0) === "Required"
						? "Requerido"
						: validationErrors.at(0)}
				</p>
			)}
		</>
	);
}

export function Textarea({
	name,
	...inputProps
}: ComponentProps<"textarea"> & { name: string }) {
	const formContext = useFormContext();
	const fieldState = formContext.value.fields[name];

	// Defensive check - render basic textarea during hydration
	if (!fieldState) {
		return <textarea {...inputProps} name={name} />;
	}

	const { hasErroredOnce, validationErrors, validator } = fieldState;

	return (
		<>
			<textarea
				{...inputProps}
				name={name}
				onBlur={async (e) => {
					const value = e.currentTarget.value;
					if (value === "") return;
					formContext.validateField(name, value, validator);
				}}
				onInput={async (e) => {
					if (!hasErroredOnce) return;
					const value = e.currentTarget.value;
					formContext.validateField(name, value, validator);
				}}
			/>
			{validationErrors && validationErrors.length > 0 && (
				<p className="text-red-500 text-xs mt-1">
					{validationErrors.at(0) === "Required"
						? "Requerido"
						: validationErrors.at(0)}
				</p>
			)}
		</>
	);
}

const MessageSucceeded = () => {
	return (
		<div className="flex">
			<div className="m-auto lg:flex gap-4 text-center justify-items-center lg:gap-10">
				<div className="content-center pb-14 lg:order-2 lg:pb-0">
					<h3 className="font-bold text-4xl pb-10 lg:pb-4 lg:text-5xl">
						Muchas gracias
					</h3>
					<p className="lg:text-xl lg:font-bold">
						Recibimos su mensaje
					</p>
					<p className="text-md lg:text-xl">
						Nos pondremos en contacto a la brevedad
					</p>
				</div>
				<div className="w-52 h-52 lg:order-1">
					<picture>
						<source type="image/avif" />
						<img
							src={success.src}
							alt="ekomod-logo"
							width={208}
							height={208}
							loading="lazy"
							decoding="async"
						/>
					</picture>
				</div>
			</div>
		</div>
	);
};
