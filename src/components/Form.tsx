// Generated by simple:form

import success from "../assets/success.png";
import { type ComponentProps, createContext } from "react";
import { useContext, useState } from "react";
import {
	type FieldErrors,
	type FormState,
	type FormValidator,
	formNameInputProps,
	getInitialFormState,
	toSetValidationErrors,
	toTrackAstroSubmitStatus,
	toValidateField,
	validateForm,
} from "simple:form";

export function useCreateFormContext(
	validator: FormValidator,
	fieldErrors?: FieldErrors
) {
	const initial = getInitialFormState({ validator, fieldErrors });
	const [formState, setFormState] = useState<FormState>(initial);
	return {
		value: formState,
		set: setFormState,
		setValidationErrors: toSetValidationErrors(setFormState),
		validateField: toValidateField(setFormState),
		trackAstroSubmitStatus: toTrackAstroSubmitStatus(setFormState),
	};
}

export function useFormContext() {
	const formContext = useContext(FormContext);
	if (!formContext) {
		throw new Error(
			"Form context not found. `useFormContext()` should only be called from children of a <Form> component."
		);
	}
	return formContext;
}

type FormContextType = ReturnType<typeof useCreateFormContext>;

const FormContext = createContext<FormContextType | undefined>(undefined);

export function Form({
	children,
	validator,
	context,
	fieldErrors,
	name,
	...formProps
}: {
	validator: FormValidator;
	context?: FormContextType;
	fieldErrors?: FieldErrors;
} & Omit<ComponentProps<"form">, "method" | "onSubmit">) {
	const formContext = context ?? useCreateFormContext(validator, fieldErrors);
	const [sentSuccessfully, setSentSuccessfully] = useState(false);

	return (
		<>
			{sentSuccessfully ? (
				<MessageSucceeded />
			) : (
				<>
					<h3 className="text-5xl text-center w-full md:text-7xl lg:text-center lg:px-20 lg:pt-20">
						Cont√°ctanos
					</h3>
					<div className="md:px-10 lg:px-0 lg:self-center lg:w-[90%] lg:content-center">
						<FormContext.Provider value={formContext}>
							<form
								{...formProps}
								method="POST"
								action="/"
								className="flex flex-col gap-4 lg:grid lg:grid-cols-2 lg:content-center lg:gap-10 lg:h-auto"
								id="contact-form"
								onSubmit={async (e) => {
									e.preventDefault();
									e.stopPropagation();

									const formData = new FormData(
										e.currentTarget
									);
									formContext.set((formState) => ({
										...formState,
										isSubmitPending: true,
										submitStatus: "validating",
									}));

									const parsed = await validateForm({
										formData,
										validator,
									});

									if (parsed.data) {
										const response = await fetch(
											"/api/contact",
											{
												method: "POST",
												body: formData,
											}
										);

										if (response.ok) {
											const json = await response.json();
											if (json.success) {
												setSentSuccessfully(
													json.success
												);

												e.currentTarget.reset();
											}
										} else {
											console.log(response);
										}

										return;
									}

									formContext.set((formState) => ({
										...formState,
										isSubmitPending: false,
										submitStatus: "idle",
									}));
									formContext.setValidationErrors(
										parsed.fieldErrors
									);
								}}
							>
								{name ? (
									<input
										{...formNameInputProps}
										value={name}
									/>
								) : null}
								{children}
							</form>
						</FormContext.Provider>
					</div>
				</>
			)}
		</>
	);
}

export function Input(inputProps: ComponentProps<"input"> & { name: string }) {
	const formContext = useFormContext();
	const fieldState = formContext.value.fields[inputProps.name];
	if (!fieldState) {
		throw new Error(
			`Input "${inputProps.name}" not found in form. Did you use the <Form> component?`
		);
	}

	const { hasErroredOnce, validationErrors, validator } = fieldState;
	return (
		<>
			<input
				onBlur={async (e) => {
					const value = e.currentTarget.value;
					if (value === "") return;
					formContext.validateField(
						inputProps.name,
						value,
						validator
					);
				}}
				onInput={async (e) => {
					if (!hasErroredOnce) return;
					const value = e.currentTarget.value;
					formContext.validateField(
						inputProps.name,
						value,
						validator
					);
				}}
				{...inputProps}
			/>
			<div className="absolute top-19 lg:top-30">
				<p className="text-red-500 text-xs lg:text-base lg:font-semibold">
					{validationErrors?.at(0) === "Required"
						? "Requerido"
						: validationErrors?.at(0)}
				</p>
			</div>
		</>
	);
}

export function Select({
	name,
	options,
	...inputProps
}: ComponentProps<"select"> & {
	name: string;
	options: { value: string; label: string }[];
}) {
	const formContext = useFormContext();
	const fieldState = formContext.value.fields[name];

	if (!fieldState) {
		throw new Error(
			`Select "${name}" not found in form. Did you use the <Form> component?`
		);
	}

	const { hasErroredOnce, validationErrors, validator } = fieldState;

	return (
		<>
			<select
				{...inputProps}
				name={name}
				defaultValue={"seleccione"}
				onBlur={async (e) => {
					const value = e.currentTarget.value;
					if (value === "") return; // Avoid triggering validation on empty selection
					formContext.validateField(name, value, validator);
				}}
				onInput={async (e) => {
					if (!hasErroredOnce) return;
					const value = e.currentTarget.value;
					formContext.validateField(name, value, validator);
				}}
			>
				<option value="seleccione" disabled>
					Seleccione
				</option>
				{options.map((option) => (
					<option key={option.value} value={option.value}>
						{option.label}
					</option>
				))}
			</select>
			<div className="absolute top-19 lg:top-30">
				<p className="text-red-500 text-xs lg:text-base lg:font-semibold">
					{validationErrors?.at(0) === "Required"
						? "Requerido"
						: validationErrors?.at(0)}
				</p>
			</div>
		</>
	);
}

export function Textarea({
	name,
	...inputProps
}: ComponentProps<"textarea"> & { name: string }) {
	const formContext = useFormContext();
	const fieldState = formContext.value.fields[name];

	if (!fieldState) {
		throw new Error(
			`Textarea "${name}" not found in form. Did you use the <Form> component?`
		);
	}

	const { hasErroredOnce, validationErrors, validator } = fieldState;

	return (
		<>
			<textarea
				{...inputProps}
				name={name}
				onBlur={async (e) => {
					const value = e.currentTarget.value;
					if (value === "") return; // Avoid triggering validation on empty textarea
					formContext.validateField(name, value, validator);
				}}
				onInput={async (e) => {
					if (!hasErroredOnce) return;
					const value = e.currentTarget.value;
					formContext.validateField(name, value, validator);
				}}
			/>
			<div className="absolute top-46 lg:top-63">
				<p className="text-red-500 text-xs lg:text-base lg:font-semibold">
					{validationErrors?.at(0) === "Required"
						? "Requerido"
						: validationErrors?.at(0)}
				</p>
			</div>
		</>
	);
}

const MessageSucceeded = () => {
	return (
		<div className="flex">
			<div className="m-auto lg:flex gap-4 text-center justify-items-center lg:gap-10">
				<div className="content-center pb-14 lg:order-2 lg:pb-0">
					<h3 className="font-bold text-4xl pb-10 lg:pb-4 lg:text-5xl">
						Muchas gracias
					</h3>
					<p className="lg:text-xl lg:font-bold">
						Recibimos su mensaje
					</p>
					<p className="text-md lg:text-xl">
						Nos pondremos en contacto a la brevedad
					</p>
				</div>
				<div className="w-52 h-52 lg:order-1">
					<img src={success.src} alt="ekomod-logo" />
				</div>
			</div>
		</div>
	);
};
