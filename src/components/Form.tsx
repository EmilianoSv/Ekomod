// Generated by simple:form

import { type ComponentProps, createContext } from "preact";
import { useContext, useState } from "preact/hooks";
import { navigate } from "astro:transitions/client";
import {
	type FieldErrors,
	type FormState,
	type FormValidator,
	formNameInputProps,
	getInitialFormState,
	toSetValidationErrors,
	toTrackAstroSubmitStatus,
	toValidateField,
	validateForm,
} from "simple:form";

export function useCreateFormContext(
	validator: FormValidator,
	fieldErrors?: FieldErrors
) {
	const initial = getInitialFormState({ validator, fieldErrors });
	const [formState, setFormState] = useState<FormState>(initial);
	return {
		value: formState,
		set: setFormState,
		setValidationErrors: toSetValidationErrors(setFormState),
		validateField: toValidateField(setFormState),
		trackAstroSubmitStatus: toTrackAstroSubmitStatus(setFormState),
	};
}

export function useFormContext() {
	const formContext = useContext(FormContext);
	if (!formContext) {
		throw new Error(
			"Form context not found. `useFormContext()` should only be called from children of a <Form> component."
		);
	}
	return formContext;
}

type FormContextType = ReturnType<typeof useCreateFormContext>;

const FormContext = createContext<FormContextType | undefined>(undefined);

export function Form({
	children,
	validator,
	context,
	fieldErrors,
	name,
	...formProps
}: {
	validator: FormValidator;
	context?: FormContextType;
	fieldErrors?: FieldErrors;
} & Omit<ComponentProps<"form">, "method" | "onSubmit">) {
	const formContext = context ?? useCreateFormContext(validator, fieldErrors);

	return (
		<FormContext.Provider value={formContext}>
			<form
				{...formProps}
				method="POST"
				action="/"
				className="flex flex-col gap-4 lg:grid lg:grid-cols-2 lg:content-center lg:gap-10 lg:h-auto"
				id="contact-form"
				onSubmit={async (e) => {
					e.preventDefault();
					e.stopPropagation();

					const formData = new FormData(e.currentTarget);
					formContext.set((formState) => ({
						...formState,
						isSubmitPending: true,
						submitStatus: "validating",
					}));

					const parsed = await validateForm({ formData, validator });

					if (parsed.data) {
						const response = await fetch("/api/contact", {
							method: "POST",
							body: formData,
						});

						window.location.href = response.url;

						return;
					}

					formContext.setValidationErrors(parsed.fieldErrors);
				}}
			>
				{name ? <input {...formNameInputProps} value={name} /> : null}
				{children}
			</form>
		</FormContext.Provider>
	);
}

export function Input(inputProps: ComponentProps<"input"> & { name: string }) {
	const formContext = useFormContext();
	const fieldState = formContext.value.fields[inputProps.name];
	if (!fieldState) {
		throw new Error(
			`Input "${inputProps.name}" not found in form. Did you use the <Form> component?`
		);
	}

	const { hasErroredOnce, validationErrors, validator } = fieldState;
	return (
		<>
			<input
				onBlur={async (e) => {
					const value = e.currentTarget.value;
					if (value === "") return;
					formContext.validateField(
						inputProps.name,
						value,
						validator
					);
				}}
				onInput={async (e) => {
					if (!hasErroredOnce) return;
					const value = e.currentTarget.value;
					formContext.validateField(
						inputProps.name,
						value,
						validator
					);
				}}
				{...inputProps}
			/>
			<div class="absolute top-19 lg:top-30">
				{validationErrors?.map((e, i) => (
					<p
						class="text-red-500 text-xs lg:text-base lg:font-semibold"
						key={e}
					>
						{e === "Required" ? "Requerido" : e}
					</p>
				))}
			</div>
		</>
	);
}

export function Select({
	name,
	options,
	...inputProps
}: ComponentProps<"select"> & {
	name: string;
	options: { value: string; label: string }[];
}) {
	const formContext = useFormContext();
	const fieldState = formContext.value.fields[name];

	if (!fieldState) {
		throw new Error(
			`Select "${name}" not found in form. Did you use the <Form> component?`
		);
	}

	const { hasErroredOnce, validationErrors, validator } = fieldState;

	return (
		<>
			<select
				{...inputProps}
				name={name}
				onBlur={async (e) => {
					const value = e.currentTarget.value;
					if (value === "") return; // Avoid triggering validation on empty selection
					formContext.validateField(name, value, validator);
				}}
				onInput={async (e) => {
					if (!hasErroredOnce) return;
					const value = e.currentTarget.value;
					formContext.validateField(name, value, validator);
				}}
			>
				<option value="" disabled selected>
					Seleccione
				</option>
				{options.map((option) => (
					<option key={option.value} value={option.value}>
						{option.label}
					</option>
				))}
			</select>
			<div class="absolute top-30">
				{validationErrors?.map((e, i) => (
					<p class="text-red-500 font-semibold" key={e}>
						{e === "Required" ? "Requerido" : e}
					</p>
				))}
			</div>
		</>
	);
}

export function Textarea({
	name,
	...inputProps
}: ComponentProps<"textarea"> & { name: string }) {
	const formContext = useFormContext();
	const fieldState = formContext.value.fields[name];

	if (!fieldState) {
		throw new Error(
			`Textarea "${name}" not found in form. Did you use the <Form> component?`
		);
	}

	const { hasErroredOnce, validationErrors, validator } = fieldState;

	return (
		<>
			<textarea
				{...inputProps}
				name={name}
				onBlur={async (e) => {
					const value = e.currentTarget.value;
					if (value === "") return; // Avoid triggering validation on empty textarea
					formContext.validateField(name, value, validator);
				}}
				onInput={async (e) => {
					if (!hasErroredOnce) return;
					const value = e.currentTarget.value;
					formContext.validateField(name, value, validator);
				}}
			/>
			<div class="absolute top-63">
				{validationErrors?.map((e, i) => (
					<p class="text-red-500 font-semibold" key={e}>
						{e === "Required" ? "Requerido" : e}
					</p>
				))}
			</div>
		</>
	);
}
